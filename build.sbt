name := "fastpath-demo"
version := "2.0.0"
scalaVersion := "2.12.5"

//source generator task
sourceGenerators in Compile += Def.task {
  //_root_ is needed because there is a sbt.io package in scope
  import _root_.io.github.lukehutch.fastclasspathscanner.FastClasspathScanner
  import _root_.io.github.lukehutch.fastclasspathscanner.matchprocessor.SubclassMatchProcessor
  import com.sksamuel.scapegoat.Inspection
  import scala.collection.mutable

  val inspectionClass = classOf[Inspection]
  val inspections = mutable.ListBuffer.empty[Inspection]

  //we need to override the scanner class loader so it can find the scapegoat inspections
  val fastCPScanner = new FastClasspathScanner(inspectionClass.getPackage.getName)
  fastCPScanner
    .overrideClassLoaders(inspectionClass.getClassLoader)
    .matchSubclassesOf(
      inspectionClass,
      new SubclassMatchProcessor[Inspection] {
        override def processMatch(matchingClass: Class[_ <: Inspection]): Unit =
          inspections += matchingClass.newInstance()
      }
    ).scan()

  val AllScapegoatInspections = inspections.toList.zipWithIndex map {
    case (inspection, idx) =>
      s"""ScapegoatInspection(id = ${idx}, name = "${inspection.text}", description = "${inspection.explanation.getOrElse("No Explanation")}", defaultLevel = "${inspection.defaultLevel}"),"""
  }

  val lines = List(
    "package demo",
    "package object autogenerated {",
    "final case class ScapegoatInspection (id: Int, name: String, description: String, defaultLevel: String)",
    "val AllScapegoatInspections: List[ScapegoatInspection] = List("
  ) ++ AllScapegoatInspections ++ List(
   ")",
   "}"
  )

  val scapegoatInspectionsFile = (sourceManaged in Compile).value / "scapegoat" / "inspections.scala"
  IO.writeLines(scapegoatInspectionsFile, lines)
  Seq(scapegoatInspectionsFile)
}.taskValue
